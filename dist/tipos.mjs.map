{"version":3,"file":"tipos.mjs","sources":["../src/parse.js","../src/schema.js","../src/types.js","../src/index.js"],"sourcesContent":["export default function parse(str) {\r\n    let open = 0,\r\n        current = \"\",\r\n        block = [],\r\n        index,\r\n        fun = \"\",\r\n        args = [],\r\n        quote1 = 0,\r\n        quote2 = 0;\r\n\r\n    str = str + \" \";\r\n\r\n    for (let i = 0; i < str.length; i++) {\r\n        let letter = str[i];\r\n        switch (letter) {\r\n            case \"'\":\r\n                if (open) {\r\n                    if (!quote1) {\r\n                        quote1++;\r\n                    } else {\r\n                        quote1--;\r\n                    }\r\n                }\r\n                current += letter;\r\n                break;\r\n            case '\"':\r\n                if (open) {\r\n                    if (!quote2) {\r\n                        quote2++;\r\n                    } else {\r\n                        quote2--;\r\n                    }\r\n                }\r\n                current += letter;\r\n                break;\r\n            case \"(\":\r\n                if (quote1 || quote2) {\r\n                    current += letter;\r\n                    continue;\r\n                }\r\n                if (!open) {\r\n                    fun = current;\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                open++;\r\n                break;\r\n            case \")\":\r\n                if (quote1 || quote2) {\r\n                    current += letter;\r\n                    continue;\r\n                }\r\n                open--;\r\n                if (!open) {\r\n                    args.push(current);\r\n                    current = fun;\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n\r\n            case \",\":\r\n                if (open === 1) {\r\n                    args.push(current);\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \" \":\r\n            case \"\\n\":\r\n                if (!current) continue;\r\n                if (open) {\r\n                    current += letter;\r\n                } else {\r\n                    index = block.push({\r\n                        fun: current,\r\n                        args: args.map(str => {\r\n                            let quote = str.match(/^(')(.+)(')$/);\r\n                            quote = quote || str.match(/^(\")(.+)(\")$/);\r\n                            if (quote) {\r\n                                return quote[2];\r\n                            } else {\r\n                                return JSON.parse(str);\r\n                            }\r\n                        })\r\n                    });\r\n                    current = \"\";\r\n                    args = [];\r\n                }\r\n                break;\r\n            default:\r\n                current += letter;\r\n        }\r\n    }\r\n    return block;\r\n}\r\n","import parse from \"./parse\";\r\n\r\nexport function schema(map, filters, structure = {}) {\r\n    for (let prop in map) {\r\n        let cursor = map[prop];\r\n        switch (typeof cursor) {\r\n            case \"string\":\r\n                structure[prop] = parse(cursor)\r\n                    .map(({ fun, args }) => {\r\n                        let [all, method, optional] = fun.match(\r\n                            /([^\\?]+)(\\?){0,1}/\r\n                        );\r\n                        optional = optional === \"?\";\r\n                        return (next, data) => {\r\n                            let state = filters[method](next, data, ...args);\r\n                            return state.valid\r\n                                ? state\r\n                                : {\r\n                                      ...state,\r\n                                      optional,\r\n                                      method: state.method || method\r\n                                  };\r\n                        };\r\n                    })\r\n                    .concat(data => ({ valid: true, data }))\r\n                    .reduceRight((after, before) => data =>\r\n                        before ? before(after, data) : data\r\n                    );\r\n                break;\r\n            case \"object\":\r\n                schema(map[prop], filters, (structure[prop] = {}));\r\n                break;\r\n        }\r\n    }\r\n    return data => filter(structure, data);\r\n}\r\n\r\nexport function filter(structure, data = {}, parent) {\r\n    let valid = {},\r\n        invalid = {},\r\n        count = { valid: 0, invalid: 0 };\r\n\r\n    for (let prop in structure) {\r\n        let promise,\r\n            space = (parent ? parent + \".\" : \"\") + prop;\r\n        if (typeof structure[prop] === \"object\") {\r\n            let sub = filter(structure[prop], data[prop], space);\r\n            count.valid += sub.count.valid;\r\n            count.invalid += sub.count.invalid;\r\n            if (sub.count.valid) valid[prop] = sub.valid;\r\n            if (sub.count.invalid) {\r\n                for (let prop in sub.invalid) {\r\n                    if (!sub.optional) invalid[prop] = sub.invalid[prop];\r\n                }\r\n            }\r\n        } else {\r\n            let state = structure[prop](data[prop]);\r\n            if (state.valid) {\r\n                valid[prop] = state.data;\r\n                count.valid++;\r\n            } else {\r\n                if (state.optional) continue;\r\n                invalid[space] = state;\r\n                count.invalid++;\r\n            }\r\n        }\r\n    }\r\n\r\n    return { valid, invalid, count };\r\n}\r\n","export default class Types {\r\n    type(next, data, isType, message) {\r\n        let [all, type = \"\"] = {}.toString.call(data).match(/ ([^\\]]+)/) || [];\r\n        return type.toLowerCase() === isType\r\n            ? next(data)\r\n            : {\r\n                  valid: false,\r\n                  data\r\n              };\r\n    }\r\n    equal(next, data, compare) {\r\n        return compare === data ? next(data) : { valid: false, data };\r\n    }\r\n    minLength(next, data, min) {\r\n        return data.length >= min ? next(data) : { valid: false, data };\r\n    }\r\n    maxLength(next, data, max) {\r\n        return data.length <= max ? next(data) : { valid: false, data };\r\n    }\r\n    default(next, data, optional) {\r\n        return next(data !== undefined ? data : optional);\r\n    }\r\n    min(next, data, min) {\r\n        return data >= min ? next(data) : { valid: false, data };\r\n    }\r\n    max(next, data, max) {\r\n        return data <= max ? next(data) : { valid: false, data };\r\n    }\r\n    not(next, data, compare) {\r\n        return compare !== data ? next(data) : { valid: false, data };\r\n    }\r\n    option(next, data, ...opts) {\r\n        return opts.indexOf(data) > -1\r\n            ? next(data)\r\n            : {\r\n                  valid: false,\r\n                  data\r\n              };\r\n    }\r\n}\r\n","import { schema, filter } from \"./schema\";\r\nimport Types from \"./types\";\r\n\r\nexport default function(data) {\r\n    let types = new Types(),\r\n        filter = schema(data, types);\r\n    filter.types = types;\r\n    return filter;\r\n}\r\n"],"names":["parse","str","let","open","current","block","fun","args","quote1","quote2","i","length","letter","push","map","quote","match","JSON","schema","filters","structure","prop","cursor","ref","optional","next","data","state","method","valid","Object","concat","reduceRight","after","before","filter","parent","invalid","count","space","sub","Types","type","isType","message","toString","call","toLowerCase","equal","compare","minLength","min","maxLength","max","default","undefined","not","option","opts","indexOf","types"],"mappings":"AAAe,SAASA,EAAMC,GAC1BC,IAAIC,EAAO,EACPC,EAAU,GACVC,KAEAC,EAAM,GACNC,KACAC,EAAS,EACTC,EAAS,EAEbR,GAAY,IAEZ,IAAKC,IAAIQ,EAAI,EAAGA,EAAIT,EAAIU,OAAQD,IAAK,CACjCR,IAAIU,EAASX,EAAIS,GACjB,OAAQE,GACJ,IAAK,IACGT,IACKK,EAGDA,IAFAA,KAKRJ,GAAWQ,EACX,MACJ,IAAK,IACGT,IACKM,EAGDA,IAFAA,KAKRL,GAAWQ,EACX,MACJ,IAAK,IACD,GAAIJ,GAAUC,EAAQ,CAClBL,GAAWQ,EACX,SAECT,EAIDC,GAAWQ,GAHXN,EAAMF,EACNA,EAAU,IAIdD,IACA,MACJ,IAAK,IACD,GAAIK,GAAUC,EAAQ,CAClBL,GAAWQ,EACX,WAEJT,EAKIC,GAAWQ,GAHXL,EAAKM,KAAKT,GACVA,EAAUE,GAId,MAEJ,IAAK,IACY,IAATH,GACAI,EAAKM,KAAKT,GACVA,EAAU,IAEVA,GAAWQ,EAEf,MACJ,IAAK,IACL,IAAK,KACD,IAAKR,EAAS,SACVD,EACAC,GAAWQ,GAEHP,EAAMQ,MACVP,IAAKF,EACLG,KAAMA,EAAKO,aAAIb,GACXC,IAAIa,EAAQd,EAAIe,MAAM,gBAEtB,OADAD,EAAQA,GAASd,EAAIe,MAAM,iBAEhBD,EAAM,GAENE,KAAKjB,MAAMC,OAI9BG,EAAU,GACVG,MAEJ,MACJ,QACIH,GAAWQ,GAGvB,OAAOP,EC9FJ,SAASa,EAAOJ,EAAKK,EAASC,GACjC,IAAKlB,IAAImB,wBAAQP,EAAK,CAClBZ,IAAIoB,EAASR,EAAIO,GACjB,cAAeC,GACX,IAAK,SACDF,EAAUC,GAAQrB,EAAMsB,GACnBR,aAAKS,wBACgCP,MAC9B,mCAGJ,OADAQ,EAAwB,MAAbA,WACHC,EAAMC,GACVxB,IAAIyB,EAAQR,EAAQS,YAAQH,EAAMC,UAASnB,IAC3C,OAAOoB,EAAME,MACPF,EACAG,iBACOH,YACHH,EACAI,OAAQD,EAAMC,QAAUA,OAIzCG,gBAAOL,UAAWG,OAAO,OAAMH,KAC/BM,qBAAaC,EAAOC,mBAAWR,UAC5BQ,EAASA,EAAOD,EAAOP,GAAQA,KAEvC,MACJ,IAAK,SACDR,EAAOJ,EAAIO,GAAOF,EAAUC,EAAUC,QAIlD,gBAAOK,UAGX,SAAgBS,EAAOf,EAAWM,EAAWU,sBACzClC,IAAI2B,KACAQ,KACAC,GAAUT,MAAO,EAAGQ,QAAS,GAEjC,IAAKnC,IAAImB,KAAQD,EAAW,CACxB,IACImB,GAASH,EAASA,EAAS,IAAM,IAAMf,EAC3C,GAA+B,iBAApBD,EAAUC,GAAoB,CACrCnB,IAAIsC,EAAML,EAAOf,EAAUC,GAAOK,EAAKL,GAAOkB,GAI9C,GAHAD,EAAMT,OAASW,EAAIF,MAAMT,MACzBS,EAAMD,SAAWG,EAAIF,MAAMD,QACvBG,EAAIF,MAAMT,QAAOA,EAAMR,GAAQmB,EAAIX,OACnCW,EAAIF,MAAMD,QACV,IAAKnC,IAAImB,KAAQmB,EAAIH,QACZG,EAAIhB,WAAUa,EAAQhB,GAAQmB,EAAIH,QAAQhB,QAGpD,CACHnB,IAAIyB,EAAQP,EAAUC,GAAMK,EAAKL,IACjC,GAAIM,EAAME,MACNA,EAAMR,GAAQM,EAAMD,KACpBY,EAAMT,YACH,CACH,GAAIF,EAAMH,SAAU,SACpBa,EAAQE,GAASZ,EACjBW,EAAMD,YAKlB,aAASR,UAAOQ,QAASC,GAlCVH,CAAOf,EAAWM,IClCtB,IAAMe,2BACjBC,cAAKjB,EAAMC,EAAMiB,EAAQC,YACKC,SAASC,KAAKpB,GAAMV,MAAM,wBACpD,sBADiB,IACV0B,EAAKK,gBAAkBJ,EACxBlB,EAAKC,WAEM,OACPA,gBAGdsB,eAAMvB,EAAMC,EAAMuB,UACPA,IAAYvB,EAAOD,EAAKC,WAAiB,OAAOA,gBAE3DwB,mBAAUzB,EAAMC,EAAMyB,UACXzB,EAAKf,QAAUwC,EAAM1B,EAAKC,WAAiB,OAAOA,gBAE7D0B,mBAAU3B,EAAMC,EAAM2B,UACX3B,EAAKf,QAAU0C,EAAM5B,EAAKC,WAAiB,OAAOA,gBAE7D4B,iBAAQ7B,EAAMC,EAAMF,UACTC,OAAc8B,IAAT7B,EAAqBA,EAAOF,gBAE5C2B,aAAI1B,EAAMC,EAAMyB,UACLzB,GAAQyB,EAAM1B,EAAKC,WAAiB,OAAOA,gBAEtD2B,aAAI5B,EAAMC,EAAM2B,UACL3B,GAAQ2B,EAAM5B,EAAKC,WAAiB,OAAOA,gBAEtD8B,aAAI/B,EAAMC,EAAMuB,UACLA,IAAYvB,EAAOD,EAAKC,WAAiB,OAAOA,gBAE3D+B,gBAAOhC,EAAMC,iEACT,OAAOgC,EAAKC,QAAQjC,IAAS,EACvBD,EAAKC,WAEM,OACPA,mBCjCH,SAASA,GACpBxB,IAAI0D,EAAQ,IAAInB,EACZN,EAASjB,EAAOQ,EAAMkC,GAE1B,OADAzB,EAAOyB,MAAQA,EACRzB"}